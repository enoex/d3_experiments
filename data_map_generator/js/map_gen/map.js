/* ========================================================================    
 *
 * map.js
 * ----------------------
 *
 * Function definition to generate the actual map
 *
 * TODO: Scaling countries
 *
 * ======================================================================== */
MAP_GEN.functions.generate_map = function( map_data ){
    //If no data object was passed in, use the MAP_GEN._data object
    if(map_data === undefined){
        //Store local reference to map data
        var map_data = MAP_GEN._data;
    }

    //Empty the map div each time this function gets called
    $('#map').empty();
    $('#treemap_hidden').empty();

    //Get width and height of the svg element
    var h = $('#map')[0].offsetHeight;
    var w = $('#map')[0].offsetWidth;

    //-----------------------------------
    //Create nodes for each continent. These are static nodes which
    //  country nodes will go to
    //-----------------------------------
    //Get the number of continents 
    var num_continents = MAP_GEN._data.children.length;
    //And colors for the cirlces
    var color = d3.scale.category10();

    //Show a status update
    MAP_GEN.functions.console_log('Creating treemap');

    //-----------------------------------
    //TREEMAP
    //
    //Get Treemap of data so we know starting positions for continents
    //-----------------------------------
    var treemap = d3.layout.treemap()
        .size([w, h])
        .value(function(d) { return d.size; });

    //Select and setup the svg element 
    var svg = d3.select("#treemap_hidden").append("svg:svg")
        .attr("width", w)
        .attr("height", h)
        .append("svg:g")
            .attr("transform", "translate(-.5,-.5)");

    //Store reference to cells 
    MAP_GEN.treemap_cells = []; 

    //Create a cell for each treemap element
    var cell = svg.data([MAP_GEN._data]).selectAll("g")
        .data(treemap)
        .enter().append("svg:g")
            .attr("class", "cell")
            .attr("transform", function(d) { 
                return "translate(" + d.x + "," + d.y + ")"; });

    cell.append("svg:rect")
        .attr("width", function(d) { return d.dx; })
        .attr("height", function(d) { return d.dy; })
        .style("fill", function(d) { 
            //TODO: Do this the right way....
            if(d.children && d.parent !== undefined){
                MAP_GEN.treemap_cells.push(d);
            }
            return d.children ? color(d.data.name) : null; }
        );


    //Create SVG element
    svg = d3.select("#map").append("svg:svg")
        .attr("width", w)
        .attr("height", h);

    //Store a reference to the svg
    MAP_GEN._svg = svg;

    //Generate convex hull
    MAP_GEN.functions.generate_continent_convex_hulls();
}
/* ========================================================================    
 *
 * generate_continent_convex_hulls()
 *
 * ======================================================================== */
MAP_GEN.functions.generate_continent_convex_hulls = function(){
    //Generate convex hulls for each continent.  The convex hull will be
    //  generated from vertices from each country.  These vertices will be
    //  generated by creating a bounding box around each center point
    //  of each cell in the treemap
    //continent / country variables to use in the loops
    var continent, country;

    //Temp country object, used when looping through countries
    var temp_country = {};

    //Random factor and country key, used to generate jagged lines
    //Setup a random factor which will allow us to create a bounding
    //  box that doesn't look exactly like a square every time
    var random_factor = MAP_GEN.config.convex_hull_randomize_points;
    var country_key = undefined;
    //country area stored during each iteraion, used to scale coordinates
    var country_area = undefined;

    //temp_country_vertices is used to store all the vertices for all the
    //  countries for an invidual continent
    //  The format is:
    //      [ [ [x1,y1][x2,y2],... ], [ ... ], ... ]
    //      Where x1,y1, etc. are ALL the vertices for that country
    var country_vertices_combined = [];
    //Local country center points variable, will contain center points
    //  for all countries, MAP_GEN global var is set at end of loop
    var country_center_points = [];

    //Reference for cells
    var cell_left, cell_right, cell_top, cell_bottom;

    //Reference to scaling factor (sizes countries / continents)
    var scaling_factor = MAP_GEN.config.scaling_factor;

    var h = $('#map')[0].offsetHeight;
    var w = $('#map')[0].offsetWidth;

    //Function we'll use to return a 'randomized' coordinate
    function randomize_vertex(vertex, country, randomize_func){
        //Takes in a vertex (x,y coord) and adds some randomized
        //  number to it
        //Also takes in country_area, which is used to scale how far away
        //  to place the coordinates (defind in main.js)
        if(randomize_func === undefined){
            randomize_func = MAP_GEN.config.convex_hull_randomize_points;
        }
        //Return x,y randomized.  This will cause the continents to not
        //  look so rectangular
        var ret_vertex = [
            vertex[0] + randomize_func(country.area),
            vertex[1] + randomize_func(country.area)
        ];

        //-------------------------------
        //Make sure vertex never goes outside country bounds
        //-------------------------------
        var offset_amount = 4;
        //Make sure it's not less than 0,0
        if(ret_vertex[0] < 0){
            ret_vertex[0] = offset_amount;
        }
        if(ret_vertex[1] < 0){
            ret_vertex[1] = offset_amount;
        }

        //Make sure it doesn't go outside the svg viewport
        if(ret_vertex[0] > w){
            ret_vertex[0] = w-offset_amount;
        }
        if(ret_vertex[1] > h){
            ret_vertex[1] = h-offset_amount;
        }

        //-------------------------------
        //Check for country bounds
        //left
        if(ret_vertex[0] < country.x){
            ret_vertex[0] = country.x - offset_amount;
        }
        //right
        if(ret_vertex[0] > country.x + country.dx){
            ret_vertex[0] = (country.x + country.dx) - offset_amount; 
        }
        //top
        if(ret_vertex[1] < country.y){
            ret_vertex[1] = country.y + offset_amount;
        }
        //bottom
        if(ret_vertex[1] > country.y + country.dy){
            ret_vertex[1] = (country.y + country.dy) - offset_amount;
        }


        //-------------------------------
        //Return the adjusted vertex
        return ret_vertex;
    }

    //Variables to use when creating country vertices
    //  ephemeral variables, get overwritten each loop iteration
    var top_left, top_right,
        bottom_left, bottom_right;
    var country_border_round_amount = MAP_GEN.config.country_border_round_amount;

    //SVG border group element
    var continent_group_border = MAP_GEN._svg.append('svg:g')
        .attr('id', 'continent_borders_group');

    //Create a group for the continent polygons
    var continent_border_polygon = MAP_GEN._svg.append('svg:g')
        .attr('id', 'continent_border_polygons');
    //Used to store a reference to each continent group which contains
    //  a polygon and clip path
    var continent_polygon_clip_group = undefined;

    //country area minimum and maximum values, used to setup d3 scale
    var country_area_minmax = [0,0];

    //-----------------------------------
    //
    //First build the country area scale
    //
    //-----------------------------------
    //Setup continent vertices based on polygon data of each country
    //  Setup array to store min and max values
    for(continent in MAP_GEN.treemap_cells){
        if(MAP_GEN.treemap_cells.hasOwnProperty(continent)){
            for(country in MAP_GEN.treemap_cells[continent].children){
                if(MAP_GEN.treemap_cells[continent].children.hasOwnProperty(
                    country)){
                    //Store reference to this current country
                    temp_country = MAP_GEN.treemap_cells[
                        continent].children[country]; 

                    //Set min and max
                    if(temp_country.area < country_area_minmax[0]){
                        country_area_minmax[0] = temp_country.area;
                    }
                    if(temp_country.area > country_area_minmax[1]){
                        country_area_minmax[1] = temp_country.area;
                    }
                }
            }
        }
    }
    //Setup scale
    MAP_GEN.config.country_area_scale = d3.scale.linear()
        .domain(country_area_minmax)
        .range(MAP_GEN.config.country_area_scale_range);
    
    //-----------------------------------
    //
    //Build points for each country
    //
    //-----------------------------------
    //Setup continent vertices based on polygon data of each country
    for(continent in MAP_GEN.treemap_cells){
        if(MAP_GEN.treemap_cells.hasOwnProperty(continent)){
            //Do the same thing for country_vertices_combined
            country_vertices_combined.push([]);
            //And for the center poitnts
            country_center_points.push([]);
            //Add a group for each continent
            continent_polygon_clip_group = continent_border_polygon.append('g')
                .attr('id', 'continent_group_' + continent);

            //-----------------------------------
            //Go through each country and add to single_continent_vertices
            //-----------------------------------
            for(country in MAP_GEN.treemap_cells[continent].children){
                if(MAP_GEN.treemap_cells[continent].children.hasOwnProperty(
                    country)){
                    //Store reference to this current country
                    temp_country = MAP_GEN.treemap_cells[
                        continent].children[country]; 

                    cell_left = temp_country.x;
                    cell_top = temp_country.y;
                    cell_right = temp_country.x + temp_country.dx;
                    cell_bottom = temp_country.y + temp_country.dy;

                    //Push the center point of this country to the 
                    //  country_center_points array
                    country_center_points[country_center_points.length-1].push(
                        [temp_country.x + (temp_country.dx / 2),
                        temp_country.y + (temp_country.dy / 2)]
                    );

                    //Store the area
                    country_area = temp_country.area;
                    

                    //-------------------
                    //Create bounding box for continent
                    //  "box" should be turned into something that doesn't 
                    //  look so square, man
                    //-------------------
                    //TODO: Create multiple vertices to avoid square edges
                    //Set up vertices
                    /*
                    cell_left = (-Math.abs(
                        (cell_left - (cell_left * scaling_factor))/2)
                        + Math.random() * (cell_left - (cell_left 
                            * scaling_factor)));
                    */
                    top_left = [
                        cell_left,
                        cell_top];
                    top_left = randomize_vertex(top_left, temp_country);

                    top_right = [
                        cell_right,
                        cell_top];
                    top_right = randomize_vertex(top_right, temp_country);

                    bottom_right = [
                        cell_right,
                        cell_bottom];
                    bottom_right = randomize_vertex(bottom_right, temp_country);
                    
                    bottom_left = [
                        cell_left,
                        cell_bottom];
                    bottom_left = randomize_vertex(bottom_left, temp_country);

                    //--------------------
                    //Add to the country_vertices_combined array
                    //--------------------
                    //We want to 'round' each corner, so we'll push two coordinates
                    //  for each point

                    //--------
                    //Top Left
                    //--------
                    country_vertices_combined[
                        country_vertices_combined.length-1].push(
                            [top_left[0] - country_border_round_amount(country_area),
                            top_left[1] + country_border_round_amount(country_area)]
                    );
                    country_vertices_combined[
                        country_vertices_combined.length-1].push(
                            [top_left[0] + country_border_round_amount(country_area),
                            top_left[1] - country_border_round_amount(country_area)]
                    );

                    //--------
                    //Top Right
                    //--------
                    country_vertices_combined[
                        country_vertices_combined.length-1].push(
                            [top_right[0] - country_border_round_amount(country_area),
                            top_right[1] - country_border_round_amount(country_area)]
                    );
                    country_vertices_combined[
                        country_vertices_combined.length-1].push(
                            [top_right[0] + country_border_round_amount(country_area),
                            top_right[1] + country_border_round_amount(country_area)]
                    );
                    //--------
                    //Bottom Right
                    //--------
                    country_vertices_combined[
                        country_vertices_combined.length-1].push(
                            [bottom_right[0] + country_border_round_amount(country_area),
                                bottom_right[1] - country_border_round_amount(country_area)]
                    );
                    country_vertices_combined[
                        country_vertices_combined.length-1].push(
                            [bottom_right[0] - country_border_round_amount(country_area),
                                bottom_right[1] + country_border_round_amount(country_area)]
                    );
                    //--------
                    //Bottom Left
                    //--------
                    country_vertices_combined[
                        country_vertices_combined.length-1].push(
                            [bottom_left[0] + country_border_round_amount(country_area),
                            bottom_left[1] + country_border_round_amount(country_area)]
                    );
                    country_vertices_combined[
                        country_vertices_combined.length-1].push(
                            [bottom_left[0] - country_border_round_amount(country_area),
                            bottom_left[1] - country_border_round_amount(country_area)]
                    );
                }
            }


            //---------------------------
            //
            //Draw outlines around continent
            //
            //NOTE: This must come before the continent polygon itself so the
            //  outlines will be overridden
            //---------------------------
            //TODO: DO THIS THE RIGHT WAY 
            //  Copy an existing polygon instead of drawing it like this again...?
            
            //Draw lines around the continent
            function create_outline(continent, scaling_factor, outline_number){
                continent_polygon_clip_group.selectAll('path_' + continent)
                    .data([d3.geom.hull(
                        country_vertices_combined[
                            country_vertices_combined.length-1
                        ]
                    )])
                    .enter().append("svg:path")
                    .attr('id', function(d){
                        return 'continent_border_polygon_border_' + continent
                    })
                    .attr('class', 'continent_border_polygon_outline_' + outline_number)
                    .attr('transform', function(d,i){
                        //scale it
                        var cur_continent = MAP_GEN.treemap_cells[continent];
                        //GET CENTER X
                        var center_x = cur_continent.x + (cur_continent.dx/2);
                        //GET CENTER Y
                        var center_y = cur_continent.y + (cur_continent.dy/2);
                        ret = 'translate(' 
                            + (-center_x * (scaling_factor - 1)) + ', ' 
                            + (-center_y * (scaling_factor - 1)) 
                            + ') scale(' + scaling_factor + ') '
                            //+ 'rotate(' 
                            //    + (-10 + Math.random() * 20) 
                            //    + ', ' + center_x + ', ' + center_y + ')'
                        return ret;
                    })
                    .attr("d", function(d) { 
                        //Set the country key to be a combination of i 
                        // and j
                        //  i is the current continent key 
                        return MAP_GEN.functions.generate_jagged_continent_borders(
                            d,
                            continent);
                });
            }
            create_outline(continent, 1.05, 1);
            create_outline(continent, 1.1, 2);
            create_outline(continent, 1.15, 3);

            //---------------------------
            //
            //Create a CONTINENT polygon based on the convex hull based
            //  on the points from each country
            //
            //---------------------------
            continent_polygon_clip_group.selectAll('path_' + continent)
                .data([d3.geom.hull(
                    country_vertices_combined[
                        country_vertices_combined.length-1
                    ]
                )])
                .enter().append("svg:path")
                .attr('id', function(d){
                    return 'continent_border_polygon_' + continent
                })
                .attr('class', 'continent_border_polygon')
                .attr("d", function(d) { 
                    //Set the country key to be a combination of i 
                    // and j
                    //  i is the current continent key 
                    return MAP_GEN.functions.generate_jagged_continent_borders(
                        d,
                        continent);
            });

            //---------------------------
            //
            //Create clipping path (for voronoi diagram)
            //
            //---------------------------
            continent_clip_path = continent_polygon_clip_group.append(
                'svg:clipPath')
                .attr('id', 'continent_border_clip_path_' + continent);

            continent_clip_path.selectAll('path_' + continent)
                .data([d3.geom.hull(
                    country_vertices_combined[
                        country_vertices_combined.length-1
                    ]
                )])
                .enter().append("svg:path")
                .attr('id', function(d){
                    return 'continent_border_clip_path_path' + continent
                })
                .attr('class', 'continent_border_clip_path')
                .attr("d", function(d) { 
                    //NOTE: The generate_jagged_continent_borders will return
                    //  a cached path
                    return MAP_GEN.functions.generate_jagged_continent_borders(
                        d,
                        continent);
            });
        }
    }

    //Store a global reference to them
    MAP_GEN.country_vertices = country_vertices_combined;
    MAP_GEN.country_center_points = country_center_points;

    
    //Generate Countries (voronoi diagrams)
    MAP_GEN.functions.generate_voronoi_countries();

}

/* ========================================================================    
 * Generate jagged_continent_borders path string
 * ======================================================================== */
MAP_GEN.functions.generate_jagged_continent_borders = function(d, 
    country_key){
    //This function takes in an array of points (d) and returns a path
    //  string which can be used to generate paths (clipping / polygon
    //  paths)
    //It also takes in a country_key which is used to 'cache' this
    //  function.  This function will save the resulting path string
    //  in MAP_CONFIG.jagged_border_paths[country_key]
    //See if the country key was passed in and if it already exists
    if(country_key !== undefined){
        if(MAP_GEN.jagged_border_paths[country_key] !== undefined){
            //The path string already exists, so return it
            return MAP_GEN.jagged_border_paths[country_key];
        }
    }
    if(d === undefined){ return false; }

    //Country vertex contains the vertex for a single country
    var country_vectex = [];
    var random_factor = undefined;
    var jagged_step_amount = MAP_GEN.config.jagged_step_amount;
    var jaggedness_factor = MAP_GEN.config.jaggedness_factor;

    var use_x_coord = true;
    var use_y_coord = true;
    var jagged_vertex = [];

    //Use x1, x2 and y1, y2 to keep things clearer
    //  This gets set in the for loop below
    var x1 = 0;
    var x2 = 0;
    var y1 = 0;
    var y2 = 0;

    var num_iteraions = 0;
    var i_jagged = 0;

    //We have the points for the convex hull already,
    //  so let's randomize it a bit
    //reset the variable
    jagged_borders = [];

    //Loop through the continent's vertices and
    //  add them, along with intermediate points (to
    //  create the jagged effect) to the jagged_borders
    //  array
    for(k=0, d_len=d.length; k < d_len; k++){

        //Use x1, x2 and y1, y2 to keep things clearer
        x1 = d[k][0];
        y1 = d[k][1];

        //Add the current vertex to the jagged_borders
        jagged_borders.push([
            x1,
            y1
        ]);

        //If we're not at the final vertex, then add 
        //  some points in between this vertex and the
        //  next one
        //if(k==2){

        if(k + 1 < d_len){
            //Set x2 and y2 to the next vertex coords
            x2 = d[k+1][0];
            y2 = d[k+1][1];
        }else{
            //We're at the final vertex so set the next
            //  vertex to be the very first vertex of the set
            x2 = d[0][0];
            y2 = d[0][1];
        }

        
        //Get the number of iterations
        //See if the X or Y is the 'limited' dimension (whatver
        //  difference is larger, we'll use it to see how get the
        //  number of iterations)
        if(Math.abs(x1-x2) > Math.abs(y1-y2)){
            //Get the number of iterations based on the X difference
            num_iterations = (Math.abs(x1-x2) / jagged_step_amount);
        }else{
            //Same concept as above, but with X
            //Get the number of iterations based on the Y difference
            num_iterations = (Math.abs(y1-y2) / jagged_step_amount);
        }

        for(i_jagged=0;i_jagged<num_iterations;i_jagged++){
            //Add some random vertices
            // We'll do this in a loop so we can add
            // an arbitrary amount of jaggedness

            //The way this works is we add a vertex
            //  in between the current point and the
            //  next one (this doesn't happen if we're 
            //  at the last index
            //The 'in between' points will be added
            //  based on some 'step' variable (
            //  as opposed to recursively getting
            //  midpoints or something).  The step
            //  variable will be either negative
            //  or positive depending if the
            //  next continent border vertex is
            //  greater or less than the current
            //  one
            //
            //We need to see which coords need to be checked.
            //  For instance, if the coords look like
            //  (19,0) to (22,0) then we don't need to check for
            //  the y coord when we're doing the step comparisons.
            //
            //  The check uses whatever step factor that was
            //  specified above
            //
            //  If vertex A (d[k]) and vertex B (d[k+1]) form a
            //  straight line, then we only need to check for one
            //  coord dimension (check for x if the line 
            //  is horizontal, y if the line is vertical)
            //
            //  If they form a diagonal line, we need to check for
            //  BOTH
            check_x_coord = false;
            check_y_coord = false;
            //We need to keep track of if
            //  the x and y coords should be used.
            //  If the step_amount goes over the
            //  next coordinates location, we dont
            //  want to use it
            use_x_coord = true;
            use_y_coord = true;
            
            //xj is x1 + local_step_amount, which is defined in
            // the checks below (xj might be negative)       
            //Reset xj and yj to 0
            yj = 0
            xj = 0

            //By default, the jagged_vertex
            //will contain the next 
            //  point's coords
            jagged_vertex = [
                x2,
                y2
            ];
            
            //The current step amount is equal to
            //  the base step amount * the current
            //  iteration
            local_step_amount = (jagged_step_amount
                * i_jagged);

            //---------------
            //Check for use_xy_coord variables
            //---------------
            //X
            //-----------
            //Check to see if we need to make the
            //  step variable positive or negative
            if(x1 < x2){
                //Positive amount 
                //Get xj 
                xj = x1 + local_step_amount;
                
                //Set the check_x_coord variable 
                //  The check is done by seeing if x1 plus the 
                //  step amount exceeds x2.  If it doesn't, we
                //  need to check the x coord
                if(x1 + jagged_step_amount <= x2){
                    check_x_coord = true

                    //Check if this amount exceeds
                    //  the next vertex
                    //This is ignored if check_x_coord is false
                    if(xj >= x2){
                        //Dont use the x coord
                        use_x_coord = false;
                    }
                }
            }else{
                //Negative amount
                local_step_amount = (local_step_amount 
                    * -1);
                xj = x1 + local_step_amount;

                //Set check_x_coord
                //  Use greater than since we're using negative coords
                if(x1 + (jagged_step_amount * -1) >= x2){
                    check_x_coord = true;
                }
                //Set use_x_coord
                if(xj <= x2){
                    //Dont use the x coord
                    use_x_coord = false;
                }
            }

            //-----------
            //Y
            //-----------
            //NOTE: Coord starts in top left, but this doesn't
            //  affect the logic we need to do to compare y1 and y2
            //reset local step count
            local_step_amount = (jagged_step_amount
                * i_jagged);

            if(y1 < y2){
                //Positive amount 
                yj = y1 + local_step_amount;

                //Set check_y_coord
                if(y1 + jagged_step_amount <= y2){
                    check_y_coord = true
                }

                //Set use_y_coord
                if(yj >= y2){
                    use_y_coord = false;
                }
            }else{
                //Negative amount
                local_step_amount = (local_step_amount 
                    * -1);
                yj = y1 + local_step_amount;
                
                //Set check_x_coord
                //  Use greater than since we're using negative coords
                if(y1 + (jagged_step_amount * -1) >= y2){
                    check_y_coord = true;
                }
                if(yj <= y2){
                    //Dont use the x coord
                    use_y_coord = false;
                }
            }

            //-----------------------
            //
            //Check for diagonal lines and set slope
            //
            //-----------------------
            if(check_x_coord === true && check_y_coord === true){
                //This is a diagonal line

                //See if the X or Y is the 'limited' dimension (whatver
                //  difference is larger, we'll use it to see how get the
                //  number of iterations)
                if(Math.abs(x1-x2) > Math.abs(y1-y2)){
                    //Set yj.  Get the 'local step amount' (y1-y2 / num_iterations)
                    yj = ( Math.abs(y1-y2) / num_iterations );
                    //The current yj is based on current iteration
                    yj = i_jagged * yj;
                    //If y1 is >= y2, make yj negative
                    if(y1>=y2) { yj *= -1 }
                    //Set yj to be y1 + yj, which means set the current y value to
                    //  be the yj we set above plus the starting y1 value
                    yj = y1 + yj;
                    //Because we just set yj, we will _always_ want to use it
                    jagged_vertex[1] = yj;

                }else{
                    //Set xj.  Get the 'local step amount' 
                    xj = ( Math.abs(x1-x2) / num_iterations );
                    //The current xj is based on current iteration
                    xj = i_jagged * xj;
                    if(x1>=x2) { xj *= -1 }
                    xj = xj + x1;
                    jagged_vertex[0] = xj;
                }
            }

            //-----------------------
            //
            //Setup jagged vertex
            //
            //-----------------------
            //Note: Because we check for diagnoal lines above, this
            //  will really only apply for horizontal or vertical lines
            //Setup X and Y Coords for jagged_vertex
            //  Determine if the base should be xj/yj
            //  or if it should stay as x1 / x2 (for 
            //  straight line segments)
            if(check_x_coord === true){
                if(use_x_coord === true){
                    jagged_vertex[0] = xj;
                }
            }

            if(check_y_coord === true){
                if(use_y_coord === true){
                    jagged_vertex[1] = yj;
                }
            }

            //-----------------------
            //Setup jagged vertex values
            //-----------------------
            // X Coord
            //-----------------------
            jagged_vertex[0] += (
                (jaggedness_factor * -1)
                    + (Math.random() 
                    * (jaggedness_factor * 2))
                );

            //Occasionally make the borders 'really' jagged
            if(Math.random() * 100 < MAP_GEN.config.jagged_extra_random_percent_x){
                jagged_vertex[0] += (
                    (Math.random() 
                    * ((jaggedness_factor * 2) 
                        * MAP_GEN.config.jagged_extra_random_scale_x))
                )
            }

            // Y Coord
            //-----------------------
            jagged_vertex[1] += (
                (jaggedness_factor * -1)
                    + (Math.random() 
                    * (jaggedness_factor * 2))
                );

            //Occasionally make the borders 'really' jagged
            if(Math.random() * 100 < MAP_GEN.config.jagged_extra_random_percent_y){
                jagged_vertex[1] += (
                    (Math.random() 
                    * ((jaggedness_factor * 2)
                        * MAP_GEN.config.jagged_extra_random_scale_y))
                )
            }
        
            //Add the point
            jagged_borders.push(
                [ jagged_vertex[0],
                    jagged_vertex[1]
                ]
            );
        }
    }

    //Store the resulting string (cache the result of this function)
    if(country_key !== undefined){
        MAP_GEN.jagged_border_paths[country_key] = 'M' 
            + jagged_borders.join('L') + 'Z'; 
    }

    //Return the path
    return MAP_GEN.jagged_border_paths[country_key];

}
/* ========================================================================    
 *
 * generate_voronoi_countries()
 *
 * ======================================================================== */
MAP_GEN.functions.generate_voronoi_countries = function(){
    //TODO: Do a voronoi diagram for EACH continent, not just a single diagram
    //Show status update
    MAP_GEN.functions.console_log('Drawing voronoi diagram for countries');

    var h = $('#map')[0].offsetHeight;
    var w = $('#map')[0].offsetWidth;
    var continent_group = undefined;
    var country_group = undefined;
    var continent;

    //country_group = MAP_GEN._svg.append('svg:g')
    //    .attr('id', 'country_borders_groups');

    for(continent in MAP_GEN.country_center_points){
        if(MAP_GEN.country_center_points.hasOwnProperty(continent)){
            continent_group = MAP_GEN._svg.selectAll('#continent_group_' 
                + continent);
            //Create a country group 
            //  and add countries to the continent group
            country_group = continent_group.append('svg:g')
                .attr('id', 'contry_border_groups_' + continent)
                .attr('class', 'country_border_group')
                .selectAll(".country_border")
                    .data(d3.geom.voronoi(MAP_GEN.country_center_points[continent]))
                    .enter().append('svg:g')
                        .attr('id', function(d,i){
                            return ('country_polygon_group_' 
                                + continent + '_' + i);
                        })

            //Add the path polygon first
            country_group.append("svg:path")
                .attr('class', 'country_border_path')
                .attr('clip-path', function(d,i){
                    return "url(#continent_border_clip_path_" + continent + ")";
                })
                .attr('id', function(d,i){
                    return 'country_voronoi_' + continent + '_' + i;
                })
                .attr("d", function(d) { 
                    // d contains an array of points
                    //  so let's just add some new points in between each set
                    var data_points = [];
                    var d_length=d.length;

                    for(var i=0; i<d_length; i++){
                        //Push the first point
                        data_points.push(d[i]);

                        //Randomize the borders a little bit.
                        //Push a point in between this index and the next
                        // if(i + 1 !== d_length){
                        //     data_points.push([
                        //         //push x
                        //         ((d[i][0] + d[i+1][0]) / 2) + 2,
                        //         //push y
                        //         ((d[i][1] + d[i+1][1]) / 2) + 2
                        //     ]);
                        // }
                    }

                    if(data_points.length > 0){
                        return "M" + data_points.join("L") + "Z"; 
                    }else{
                        //Create a square that extends past the map div
                        data_points = [
                            [-w, -h],
                            [w*2, -h],
                            [w*2, h*2],
                            [-w, h*2]
                        ];
                    }
                    return "M" + data_points.join("L") + "Z"; 
                });                        

                //Note: We could add the label here, but it could be 
                //  overlapped by other countries

            }
        }

    //------------------------------------------------------------------------
    //Add Labels to a new group
    //------------------------------------------------------------------------
    
    //Create a new label for each country
    for(continent in MAP_GEN.country_center_points){
        if(MAP_GEN.country_center_points.hasOwnProperty(continent)){
            //Get the SVG group
            continent_group = MAP_GEN._svg.select('#continent_group_' + continent)
                .append('svg:g')
                .attr('id', 'country_label_group');

            //Get into each label
            for(country in MAP_GEN.country_center_points[continent]){
                if(MAP_GEN.country_center_points[continent].hasOwnProperty(country)){ 
                        //Add a new label
                        continent_group.append('svg:text')
                            .attr('x', function(d){
                                return (MAP_GEN.treemap_cells[
                                    continent].children[country].x 
                                    + (MAP_GEN.treemap_cells[
                                    continent].children[country].dx/2));
                            })
                            .attr('y', function(d,i){
                                var y = ((MAP_GEN.treemap_cells[
                                    continent].children[country].y 
                                    + (MAP_GEN.treemap_cells[
                                    continent].children[country].dy/2))
                                    //Use a closure
                                    + (function(){
                                        /*
                                        var height = Math.abs(
                                            MAP_GEN.treemap_cells[
                                                continent].children[i].y - 
                                            MAP_GEN.treemap_cells[
                                                continent].children[i].dy 
                                        );
                                        var pos = (-height 
                                        + (Math.random() * (height*2)));
                                        */
                                        //Randomize position
                                        var pos = -30 + Math.random() * 60;
                                        return pos;
                                        })()
                                );
                                return y;
                            })
                            .attr('text-anchor', 'middle')
                            .attr('class', 'country_label_text')
                            .text(function(){
                                return (MAP_GEN._data.children[
                                    continent].children[country].name);
                            });
                }
            }
        }
    }

    MAP_GEN.functions.scale_continents();
}

/* ========================================================================    
 *
 * generate_voronoi_countries()
 *
 * ======================================================================== */
MAP_GEN.functions.scale_continents = function(){
    var scaling_factor = MAP_GEN.config.scaling_factor;
    var ret=undefined;
    var continent; 

    //Scale each continent
    for(continent in MAP_GEN.treemap_cells){
        if(MAP_GEN.treemap_cells.hasOwnProperty(continent)){
            d3.select('#continent_group_' + continent)
                .attr('transform', function(d){
                    //scale it
                    var cur_continent = MAP_GEN.treemap_cells[continent];
                    //GET CENTER X
                    var center_x = cur_continent.x + (cur_continent.dx/2);
                    //GET CENTER Y
                    var center_y = cur_continent.y + (cur_continent.dy/2);
                    ret = 'translate(' 
                        + (-center_x * (scaling_factor - 1)) + ', ' 
                        + (-center_y * (scaling_factor - 1)) 
                        + ') scale(' + scaling_factor + ') '
                        + 'rotate(' 
                            + (-10 + Math.random() * 20) 
                            + ', ' + center_x + ', ' + center_y + ')'
                    return ret;
                })
        }
    }
}
